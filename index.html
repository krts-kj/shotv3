<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>モバイル対応シューティング</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body{margin:0;background:#111;overflow:hidden;font-family:sans-serif}
canvas{display:block;margin:auto;background:#111}
#startBtn{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
  padding:15px 30px;font-size:20px;background:lime;color:#000;border:none;
  border-radius:8px;cursor:pointer;display:none;}
#ranking{position:absolute;left:50%;top:20%;transform:translateX(-50%);
  color:white;font-size:16px;text-align:right;display:none;}
#joystick {
  position: absolute; left:20px; bottom:20px;
  width:160px; height:160px; border-radius:50%; opacity:0.5; background:gray;
}
#stick {
  position: absolute; left:65px; top:65px;
  width:30px; height:30px; background:darkgray; border-radius:50%;
}
</style>
</head>
<body>
<canvas id="gameCanvas" width="480" height="640"></canvas>
<button id="startBtn">START</button>
<div id="ranking"></div>
<div id="joystick"><div id="stick"></div></div>

<script type="module">
/* ------------------------------------------------------------
   🔹 Firebase v9+ モジュール版 初期化とランキング機能
------------------------------------------------------------ */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
import { getFirestore, collection, addDoc, getDocs, query, orderBy, limit } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";

// ✅ あなたの Firebase プロジェクト設定に差し替えてください
const firebaseConfig = {
  apiKey: "AIzaSyDhF1YsbkHWO6yf28Hm2RLRvbSRA-sXXfk",
  authDomain: "shotgan-pj-by-kj.firebaseapp.com",
  projectId: "shotgan-pj-by-kj",
  storageBucket: "shotgan-pj-by-kj.firebasestorage.app",
  messagingSenderId: "720122994055",
  appId: "1:720122994055:web:ae891e5b85adb86e65c722"
};

// 初期化
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// 🔹 ランキング保存
async function addRanking(name, score){
  try {
    await addDoc(collection(db, "scores"), {
      name: name,
      score: score,
      createdAt: new Date()
    });
  } catch(e){ console.error("スコア保存失敗:", e); }
}

// 🔹 ランキング取得
async function showRanking(){
  const rankingDiv = document.getElementById("ranking");
  rankingDiv.innerHTML = "<h3>RANKING</h3>";
  const q = query(collection(db, "scores"), orderBy("score", "desc"), limit(5));
  const snapshot = await getDocs(q);
  snapshot.forEach((doc, i)=>{
    const d = doc.data();
    rankingDiv.innerHTML += `${i+1}. ${d.name} : ${d.score}<br>`;
  });
  rankingDiv.style.display = "block";
}

/* ------------------------------------------------------------
   🔹 ゲーム本体
------------------------------------------------------------ */
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
const startBtn=document.getElementById('startBtn');
const rankingDiv=document.getElementById('ranking');

let keys={}, moveX=0, moveY=0;
document.addEventListener('keydown',e=>keys[e.key]=true);
document.addEventListener('keyup',e=>keys[e.key]=false);

// 仮想スティック
const joystick=document.getElementById('joystick');
const stick=document.getElementById('stick');
stick.addEventListener('touchmove', e=>{
  const touch=e.touches[0];
  const rect=joystick.getBoundingClientRect();
  let dx=touch.clientX-rect.left-80;
  let dy=touch.clientY-rect.top-80;
  const dist=Math.sqrt(dx*dx+dy*dy);
  const maxDist=70;
  if(dist>maxDist){ dx=dx/dist*maxDist; dy=dy/dist*maxDist; }
  stick.style.left=65+dx+'px';
  stick.style.top=65+dy+'px';
  moveX=dx/10; moveY=dy/10;
});
stick.addEventListener('touchend', ()=>{
  stick.style.left='65px'; stick.style.top='65px'; moveX=0; moveY=0;
});

let frameCount=0, score=0, gameOver=true, difficulty=1;

const player={
  x:canvas.width/2,
  y:canvas.height-60,
  speed:5,
  bullets:[],
  options:[],
  maxOptions:8,
  shield:0,
  attack:1,
  pattern:'straight',
  hp:3,
  maxHp:5
};

const BELL_TYPES={YELLOW:'yellow',GREEN:'green',BLUE:'blue',RED:'red',ORANGE:'orange',WHITE:'white'};
const bells=[];
const enemies=[];
const enemyBullets=[];

// 攻撃
function shoot(){
  if(frameCount%10!==0) return;
  const bulletsToAdd=[];
  if(player.pattern==='straight'){
    bulletsToAdd.push({x:player.x,y:player.y-10,dx:0,dy:-6,atk:player.attack});
    player.options.forEach(opt=>bulletsToAdd.push({x:opt.x,y:opt.y-10,dx:0,dy:-6,atk:player.attack}));
  }else if(player.pattern==='spread'){
    bulletsToAdd.push({x:player.x,y:player.y-10,dx:-1,dy:-5,atk:player.attack});
    bulletsToAdd.push({x:player.x,y:player.y-10,dx:0,dy:-5,atk:player.attack});
    bulletsToAdd.push({x:player.x,y:player.y-10,dx:1,dy:-5,atk:player.attack});
    player.options.forEach(opt=>{
      bulletsToAdd.push({x:opt.x,y:opt.y-10,dx:-1,dy:-5,atk:player.attack});
      bulletsToAdd.push({x:opt.x,y:opt.y-10,dx:0,dy:-5,atk:player.attack});
      bulletsToAdd.push({x:opt.x,y:opt.y-10,dx:1,dy:-5,atk:player.attack});
    });
  }
  player.bullets.push(...bulletsToAdd);
}

function addOption(){ if(player.options.length<player.maxOptions) player.options.push({}); }

function collectBell(bell){
  switch(bell.type){
    case BELL_TYPES.GREEN:addOption();break;
    case BELL_TYPES.BLUE:player.shield=600;break;
    case BELL_TYPES.YELLOW:score+=1000;break;
    case BELL_TYPES.RED:player.attack*=3;break;
    case BELL_TYPES.ORANGE:player.pattern='spread';break;
    case BELL_TYPES.WHITE:if(player.hp<player.maxHp) player.hp++;break;
  }
}

function spawnEnemy(){
  const sizeArr=[{size:20,hp:1},{size:35,hp:3},{size:50,hp:5}];
  const type=sizeArr[Math.floor(Math.random()*sizeArr.length)];
  enemies.push({
    x:Math.random()*(canvas.width-type.size)+type.size/2,
    y:-type.size,
    dy:1+Math.random()*2,
    size:type.size,
    hp:type.hp + Math.floor(difficulty*5),
    maxHp:type.hp + Math.floor(difficulty*5),
    shootTimer:Math.floor(Math.random()*120)
  });
}
function spawnBell(){
  const types=Object.values(BELL_TYPES);
  bells.push({x:Math.random()*460+10,y:-10,dy:1,type:types[Math.floor(Math.random()*types.length)]});
}

function update(){
  if(gameOver) return;
  if(keys['ArrowLeft']||keys['a']) player.x-=player.speed;
  if(keys['ArrowRight']||keys['d']) player.x+=player.speed;
  if(keys['ArrowUp']||keys['w']) player.y-=player.speed;
  if(keys['ArrowDown']||keys['s']) player.y+=player.speed;
  player.x+=moveX; player.y+=moveY;
  if(player.x<20) player.x=20; if(player.x>canvas.width-20) player.x=canvas.width-20;
  if(player.y<20) player.y=20; if(player.y>canvas.height-20) player.y=canvas.height-20;
  shoot();
  player.bullets.forEach(b=>{ b.x+=b.dx; b.y+=b.dy; });
  player.bullets=player.bullets.filter(b=>b.y>-10 && b.x>0 && b.x<canvas.width);
  player.options.forEach((opt,i)=>{
    const offset=(i-(player.options.length-1)/2)*30;
    opt.x=player.x+offset; opt.y=player.y-30;
  });
  enemies.forEach((e,i)=>{
    e.y+=e.dy; e.shootTimer--;
    if(e.shootTimer<=0){
      enemyBullets.push({x:e.x,y:e.y,dx:0,dy:3});
      e.shootTimer=120-Math.min(80,difficulty*2);
    }
    player.bullets.forEach((b,j)=>{
      if(Math.abs(b.x-e.x)<e.size/2 && Math.abs(b.y-e.y)<e.size/2){
        e.hp-=b.atk; player.bullets.splice(j,1);
        if(e.hp<=0){
          enemies.splice(i,1);
          score+=Math.floor(100*difficulty*e.maxHp/5);
        }
      }
    });
    if(Math.abs(player.x-e.x)<e.size/2 && Math.abs(player.y-e.y)<e.size/2){
      if(player.shield>0){ enemies.splice(i,1); }
      else {
        if(player.options.length>0){ player.options.pop(); }
        player.hp--;
        if(player.hp<=0){ endGame(); } else { enemies.splice(i,1); }
      }
    }
  });
  enemyBullets.forEach((b,i)=>{
    b.x+=b.dx; b.y+=b.dy;
    if(Math.abs(player.x-b.x)<10 && Math.abs(player.y-b.y)<10){
      if(player.shield>0){ enemyBullets.splice(i,1); }
      else {
        if(player.options.length>0){ player.options.pop(); }
        player.hp--; enemyBullets.splice(i,1);
        if(player.hp<=0){ endGame(); }
      }
    }
  });
  bells.forEach((b,i)=>{
    b.y+=b.dy;
    if(Math.abs(player.x-b.x)<15 && Math.abs(player.y-b.y)<15){
      collectBell(b); bells.splice(i,1);
    }
  });
  if(frameCount%600===0) difficulty*=2;
  if(frameCount%(60-Math.min(55,difficulty*5))===0) spawnEnemy();
  if(frameCount%150===0) spawnBell();
  frameCount++;
}

async function endGame(){
  gameOver=true; startBtn.style.display='block';
  const name=prompt("ゲームオーバー！名前を入力してください","PLAYER");
  if(name){ await addRanking(name,Math.floor(score)); }
  showRanking();
}

function draw(){
  ctx.fillStyle="#111"; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="lime"; ctx.fillRect(player.x-10,player.y-10,20,20);
  if(player.shield>0){
    ctx.beginPath(); ctx.arc(player.x,player.y,30,0,Math.PI*2);
    ctx.strokeStyle="cyan"; ctx.lineWidth=3; ctx.stroke(); player.shield--;
  }
  ctx.fillStyle="lightgreen"; player.options.forEach(opt=>ctx.fillRect(opt.x-8,opt.y-8,16,16));
  ctx.fillStyle="white"; player.bullets.forEach(b=>ctx.fillRect(b.x-2,b.y-5,4,10));
  enemies.forEach(e=>{
    ctx.fillStyle="red"; ctx.fillRect(e.x-e.size/2,e.y-e.size/2,e.size,e.size);
    ctx.fillStyle="black"; ctx.fillRect(e.x-20,e.y-e.size/2-8,40,5);
    ctx.fillStyle="lime";
    const w=Math.max(0,(e.hp/e.maxHp)*40);
    ctx.fillRect(e.x-20,e.y-e.size/2-8,w,5);
  });
  ctx.fillStyle="orange"; enemyBullets.forEach(b=>ctx.fillRect(b.x-2,b.y-5,4,10));
  bells.forEach(b=>{
    ctx.fillStyle=b.type;
    ctx.beginPath(); ctx.arc(b.x,b.y,10,0,Math.PI*2); ctx.fill();
  });
  ctx.fillStyle="white"; ctx.font="16px sans-serif";
  ctx.fillText("SCORE:"+Math.floor(score),10,20);
  ctx.fillText("ATK:"+player.attack,10,40);
  ctx.fillText("HP:"+player.hp+"/"+player.maxHp,10,60);
  ctx.fillText("FRAME:"+frameCount,10,80);
}

function initGame(){
  player.x=canvas.width/2; player.y=canvas.height-60;
  player.bullets=[]; player.options=[]; player.shield=0;
  player.attack=1; player.pattern='straight'; player.hp=3;
  bells.length=0; enemies.length=0; enemyBullets.length=0;
  score=0; frameCount=0; difficulty=1; gameOver=false;
  startBtn.style.display='none'; rankingDiv.style.display='none';
}

function loop(){ update(); draw(); if(!gameOver) requestAnimationFrame(loop); }

startBtn.addEventListener('click',()=>{ initGame(); loop(); });
startBtn.style.display='block';
showRanking();
</script>
</body>
</html>

